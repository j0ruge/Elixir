defmodule ReportsGenerator do
  @moduledoc """
  The `ReportsGenerator` module is responsible for generating and analyzing sales reports
  from CSV files. It parses the data, aggregates results, and provides utility functions
  to extract useful insights.

  ## Overview

  Each report is built from a file containing user purchase data. The file is read line by line,
  where each line represents a record in the format:

      user_id,food_name,price

  The module uses `Enum.reduce/3` to accumulate results into a report map containing two main keys:

    * `"users"` — maps each user ID to the total amount spent.
    * `"foods"` — maps each food item to the number of times it was purchased.

  ## Public Functions

    * `build/1` — Builds a complete report from a given filename.
    * `fetch_higher_cost/2` — Fetches the entry (users or foods) with the highest total value.

  ## Examples

      iex> ReportsGenerator.build("report.csv")
      %{
        "users" => %{"1" => 45, "2" => 33, "3" => 20},
        "foods" => %{"pizza" => 4, "hambúrguer" => 2, "açaí" => 1}
      }

      iex> ReportsGenerator.fetch_higher_cost(report, "users")
      {:ok, {"1", 45}}

      iex> ReportsGenerator.fetch_higher_cost(report, "invalid_key")
      {:error, "Invalid option"}
  """

  alias ReportsGenerator.Parser

  @available_foods [
    "açaí",
    "churrasco",
    "esfirra",
    "hambúrguer",
    "pastel",
    "pizza",
    "prato_feito",
    "sushi"
  ]

  @options ["users", "foods"]

  @doc """
  Builds a complete report from a CSV file.

  This function takes a filename, reads its contents using `ReportsGenerator.Parser.parse_file/1`,
  and aggregates all data into a single report map using `Enum.reduce/3`.

  Each line in the CSV file must follow the structure:

      user_id,food_name,price

  The resulting report contains two sections:

    * `"users"` — Maps each user ID to the total amount spent.
    * `"foods"` — Maps each food name to the number of times it was purchased.

  ## Parameters

    * `filename` — The name of the file (e.g., `"report.csv"`), located in the `reports/` folder.

  ## Returns

    A map in the following format:

        %{
          "users" => %{"1" => 45, "2" => 33, "3" => 20},
          "foods" => %{"pizza" => 4, "hambúrguer" => 2, "açaí" => 1}
        }

  ## Examples

      iex> ReportsGenerator.build("report.csv")
      %{
        "users" => %{"1" => 45, "2" => 33, "3" => 20},
        "foods" => %{"pizza" => 4, "hambúrguer" => 2, "açaí" => 1}
      }
  """
  def build(filename) do
    filename
    |> Parser.parse_file()
    |> Enum.reduce(report_acc(), fn line, report -> sum_values(line, report) end)
  end

  @doc """
  Fetches the entry with the highest total value for the given report section.

  This function inspects one of the report sections — `"users"` or `"foods"` —
  and returns the entry with the highest aggregated value.

  * For `"users"`, it returns the user who spent the most.
  * For `"foods"`, it returns the most frequently purchased item.

  ## Parameters

    * `report` — The report map generated by `build/1`.
    * `option` — Either `"users"` or `"foods"`.

  ## Returns

    * `{:ok, {key, value}}` — When a valid option is provided.
    * `{:error, "Invalid option"}` — When an invalid option is passed.

  ## Examples

      iex> ReportsGenerator.fetch_higher_cost(report, "users")
      {:ok, {"1", 45}}

      iex> ReportsGenerator.fetch_higher_cost(report, "foods")
      {:ok, {"pizza", 4}}

      iex> ReportsGenerator.fetch_higher_cost(report, "invalid")
      {:error, "Invalid option"}
  """
  def fetch_higher_cost(report, option) when option in @options do
    {:ok, Enum.max_by(report[option], fn {_key, value} -> value end)}
  end

  def fetch_higher_cost(_report, _option), do: {:error, "Invalid option"}

  @doc false
  # Private helper: updates the accumulated report with data from each parsed line.
  defp sum_values([id, food_name, price], %{"foods" => foods, "users" => users} = report) do
    users = Map.put(users, id, users[id] + price)
    foods = Map.put(foods, food_name, foods[food_name] + 1)

    report
    |> Map.put("users", users)
    |> Map.put("foods", foods)

    # %{report | "users" => users, "foods" => foods}
  end

  @doc false
  # Private helper: initializes the report accumulator with zeroed data for all foods and users.
  defp report_acc do
    foods = Enum.into(@available_foods, %{}, &{&1, 0})
    users = Enum.into(1..30, %{}, &{Integer.to_string(&1), 0})

    %{"users" => users, "foods" => foods}
  end
end
